"""
Duzeltme planlayici modulu.

Duzeltme planlama, kaynak tahmini,
zaman cizelgesi, bagimlilik yonetimi,
dogrulama adimlari.
"""

import logging
from datetime import datetime, timezone
from typing import Any
from uuid import uuid4

logger = logging.getLogger(__name__)


class RemediationPlanner:
    """Duzeltme planlayici.

    Attributes:
        _plans: Plan kayitlari.
        _tasks: Gorev kayitlari.
        _verifications: Dogrulama kayitlari.
        _stats: Istatistikler.
    """

    PRIORITIES: list[str] = [
        "p0_immediate",
        "p1_urgent",
        "p2_high",
        "p3_medium",
        "p4_low",
    ]

    TASK_STATUSES: list[str] = [
        "pending",
        "in_progress",
        "completed",
        "blocked",
        "skipped",
    ]

    def __init__(self) -> None:
        """Planlayiciyi baslatir."""
        self._plans: dict[
            str, dict
        ] = {}
        self._tasks: dict[
            str, dict
        ] = {}
        self._verifications: list[
            dict
        ] = []
        self._stats: dict[str, int] = {
            "plans_created": 0,
            "tasks_created": 0,
            "tasks_completed": 0,
            "verifications_run": 0,
        }
        logger.info(
            "RemediationPlanner "
            "baslatildi"
        )

    @property
    def plan_count(self) -> int:
        """Plan sayisi."""
        return len(self._plans)

    def create_plan(
        self,
        weakness_id: str = "",
        name: str = "",
        priority: str = "p2_high",
        description: str = "",
        estimated_hours: float = 0.0,
        assigned_team: str = "",
    ) -> dict[str, Any]:
        """Duzeltme plani olusturur.

        Args:
            weakness_id: Zafiyet ID.
            name: Plan adi.
            priority: Oncelik.
            description: Aciklama.
            estimated_hours: Tahmini sure.
            assigned_team: Atanan takim.

        Returns:
            Plan bilgisi.
        """
        try:
            if (
                priority
                not in self.PRIORITIES
            ):
                return {
                    "created": False,
                    "error": (
                        f"Gecersiz: "
                        f"{priority}"
                    ),
                }

            pid = f"rp_{uuid4()!s:.8}"
            self._plans[pid] = {
                "plan_id": pid,
                "weakness_id": weakness_id,
                "name": name,
                "priority": priority,
                "description": description,
                "estimated_hours": (
                    estimated_hours
                ),
                "assigned_team": (
                    assigned_team
                ),
                "status": "pending",
                "tasks": [],
                "created_at": datetime.now(
                    timezone.utc
                ).isoformat(),
            }
            self._stats[
                "plans_created"
            ] += 1

            return {
                "plan_id": pid,
                "name": name,
                "priority": priority,
                "created": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "created": False,
                "error": str(e),
            }

    def add_task(
        self,
        plan_id: str = "",
        name: str = "",
        description: str = "",
        estimated_hours: float = 0.0,
        depends_on: list[str] | None = None,
        assignee: str = "",
    ) -> dict[str, Any]:
        """Plana gorev ekler.

        Args:
            plan_id: Plan ID.
            name: Gorev adi.
            description: Aciklama.
            estimated_hours: Tahmini sure.
            depends_on: Bagimliliklar.
            assignee: Atanan kisi.

        Returns:
            Gorev bilgisi.
        """
        try:
            plan = self._plans.get(plan_id)
            if not plan:
                return {
                    "added": False,
                    "error": (
                        "Plan bulunamadi"
                    ),
                }

            tid = f"rt_{uuid4()!s:.8}"
            task = {
                "task_id": tid,
                "plan_id": plan_id,
                "name": name,
                "description": description,
                "estimated_hours": (
                    estimated_hours
                ),
                "depends_on": (
                    depends_on or []
                ),
                "assignee": assignee,
                "status": "pending",
                "created_at": datetime.now(
                    timezone.utc
                ).isoformat(),
            }
            self._tasks[tid] = task
            plan["tasks"].append(tid)
            self._stats[
                "tasks_created"
            ] += 1

            return {
                "task_id": tid,
                "plan_id": plan_id,
                "added": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "added": False,
                "error": str(e),
            }

    def update_task_status(
        self,
        task_id: str = "",
        status: str = "in_progress",
    ) -> dict[str, Any]:
        """Gorev durumunu gunceller.

        Args:
            task_id: Gorev ID.
            status: Yeni durum.

        Returns:
            Guncelleme bilgisi.
        """
        try:
            task = self._tasks.get(task_id)
            if not task:
                return {
                    "updated": False,
                    "error": (
                        "Gorev bulunamadi"
                    ),
                }

            if (
                status
                not in self.TASK_STATUSES
            ):
                return {
                    "updated": False,
                    "error": (
                        f"Gecersiz: {status}"
                    ),
                }

            # Bagimliliklari kontrol et
            if status == "in_progress":
                for dep_id in task.get(
                    "depends_on", []
                ):
                    dep = self._tasks.get(
                        dep_id
                    )
                    if dep and dep[
                        "status"
                    ] != "completed":
                        return {
                            "updated": False,
                            "error": (
                                "Bagimlilk "
                                "tamamlanmadi"
                            ),
                        }

            task["status"] = status
            if status == "completed":
                task["completed_at"] = (
                    datetime.now(
                        timezone.utc
                    ).isoformat()
                )
                self._stats[
                    "tasks_completed"
                ] += 1

            return {
                "task_id": task_id,
                "status": status,
                "updated": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "updated": False,
                "error": str(e),
            }

    def estimate_timeline(
        self,
        plan_id: str = "",
    ) -> dict[str, Any]:
        """Zaman cizelgesi tahmin eder.

        Args:
            plan_id: Plan ID.

        Returns:
            Cizelge bilgisi.
        """
        try:
            plan = self._plans.get(plan_id)
            if not plan:
                return {
                    "estimated": False,
                    "error": (
                        "Plan bulunamadi"
                    ),
                }

            tasks = [
                self._tasks[tid]
                for tid in plan["tasks"]
                if tid in self._tasks
            ]

            total_hours = sum(
                t.get(
                    "estimated_hours", 0.0
                )
                for t in tasks
            )
            # Paralel is hesabi
            parallel = max(
                1,
                len(
                    set(
                        t.get("assignee", "")
                        for t in tasks
                        if t.get("assignee")
                    )
                ),
            )
            elapsed = (
                total_hours / parallel
                if parallel > 0
                else total_hours
            )
            completed = sum(
                1
                for t in tasks
                if t["status"]
                == "completed"
            )
            progress = (
                round(
                    completed / len(tasks),
                    2,
                )
                if tasks
                else 0.0
            )

            return {
                "plan_id": plan_id,
                "total_tasks": len(tasks),
                "completed_tasks": (
                    completed
                ),
                "total_hours": total_hours,
                "parallel_factor": parallel,
                "estimated_elapsed": round(
                    elapsed, 1
                ),
                "progress": progress,
                "estimated": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "estimated": False,
                "error": str(e),
            }

    def verify_remediation(
        self,
        plan_id: str = "",
        verifier_id: str = "",
        is_fixed: bool = True,
        notes: str = "",
    ) -> dict[str, Any]:
        """Duzeltmeyi dogrular.

        Args:
            plan_id: Plan ID.
            verifier_id: Dogrulayici ID.
            is_fixed: Duzeltildi mi.
            notes: Notlar.

        Returns:
            Dogrulama bilgisi.
        """
        try:
            plan = self._plans.get(plan_id)
            if not plan:
                return {
                    "verified": False,
                    "error": (
                        "Plan bulunamadi"
                    ),
                }

            vid = f"rv_{uuid4()!s:.8}"
            self._verifications.append({
                "verification_id": vid,
                "plan_id": plan_id,
                "verifier_id": verifier_id,
                "is_fixed": is_fixed,
                "notes": notes,
                "verified_at": (
                    datetime.now(
                        timezone.utc
                    ).isoformat()
                ),
            })

            if is_fixed:
                plan["status"] = "verified"
            else:
                plan["status"] = "reopened"

            self._stats[
                "verifications_run"
            ] += 1

            return {
                "verification_id": vid,
                "plan_id": plan_id,
                "is_fixed": is_fixed,
                "verified": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "verified": False,
                "error": str(e),
            }

    def get_summary(
        self,
    ) -> dict[str, Any]:
        """Ozet getirir."""
        try:
            by_priority: dict[
                str, int
            ] = {}
            for p in self._plans.values():
                pri = p["priority"]
                by_priority[pri] = (
                    by_priority.get(pri, 0)
                    + 1
                )

            return {
                "total_plans": len(
                    self._plans
                ),
                "total_tasks": len(
                    self._tasks
                ),
                "total_verifications": len(
                    self._verifications
                ),
                "by_priority": by_priority,
                "stats": dict(self._stats),
                "retrieved": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "retrieved": False,
                "error": str(e),
            }

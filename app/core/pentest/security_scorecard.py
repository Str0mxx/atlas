"""
Guvenlik puan karti modulu.

Genel guvenlik puani, kategori puanlari,
trend takibi, kiyaslama, iyilestirme
takibi.
"""

import logging
from datetime import datetime, timezone
from typing import Any
from uuid import uuid4

logger = logging.getLogger(__name__)


class SecurityScorecard:
    """Guvenlik puan karti.

    Attributes:
        _scores: Puan kayitlari.
        _categories: Kategori kayitlari.
        _benchmarks: Kiyaslama kayitlari.
        _improvements: Iyilestirmeler.
        _stats: Istatistikler.
    """

    CATEGORIES: list[str] = [
        "network_security",
        "application_security",
        "data_protection",
        "access_control",
        "incident_response",
        "compliance",
        "physical_security",
        "awareness_training",
    ]

    GRADES: list[str] = [
        "A",
        "B",
        "C",
        "D",
        "F",
    ]

    def __init__(self) -> None:
        """Puan kartini baslatir."""
        self._scores: list[dict] = []
        self._categories: dict[
            str, dict
        ] = {}
        self._benchmarks: dict[
            str, dict
        ] = {}
        self._improvements: list[
            dict
        ] = []
        self._stats: dict[str, int] = {
            "assessments_done": 0,
            "categories_scored": 0,
            "benchmarks_set": 0,
            "improvements_tracked": 0,
        }
        self._init_categories()
        logger.info(
            "SecurityScorecard "
            "baslatildi"
        )

    def _init_categories(self) -> None:
        """Varsayilan kategoriler."""
        for cat in self.CATEGORIES:
            self._categories[cat] = {
                "name": cat,
                "score": 0.0,
                "weight": 1.0,
                "last_assessed": None,
            }

    @property
    def overall_score(self) -> float:
        """Genel puan."""
        cats = [
            c
            for c in (
                self._categories.values()
            )
            if c["score"] > 0
        ]
        if not cats:
            return 0.0
        total_w = sum(
            c["weight"] for c in cats
        )
        if total_w == 0:
            return 0.0
        weighted = sum(
            c["score"] * c["weight"]
            for c in cats
        )
        return round(
            weighted / total_w, 1
        )

    def assess_category(
        self,
        category: str = "",
        score: float = 0.0,
        findings: int = 0,
        notes: str = "",
    ) -> dict[str, Any]:
        """Kategori degerlendirir.

        Args:
            category: Kategori adi.
            score: Puan (0-100).
            findings: Bulgu sayisi.
            notes: Notlar.

        Returns:
            Degerlendirme bilgisi.
        """
        try:
            if (
                category
                not in self.CATEGORIES
            ):
                return {
                    "assessed": False,
                    "error": (
                        f"Gecersiz: "
                        f"{category}"
                    ),
                }

            score = max(
                0.0, min(100.0, score)
            )
            grade = self._score_to_grade(
                score
            )

            self._categories[category][
                "score"
            ] = score
            self._categories[category][
                "last_assessed"
            ] = datetime.now(
                timezone.utc
            ).isoformat()

            assessment = {
                "assessment_id": (
                    f"sa_{uuid4()!s:.8}"
                ),
                "category": category,
                "score": score,
                "grade": grade,
                "findings": findings,
                "notes": notes,
                "assessed_at": (
                    datetime.now(
                        timezone.utc
                    ).isoformat()
                ),
            }
            self._scores.append(assessment)
            self._stats[
                "assessments_done"
            ] += 1
            self._stats[
                "categories_scored"
            ] += 1

            return {
                "category": category,
                "score": score,
                "grade": grade,
                "assessed": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "assessed": False,
                "error": str(e),
            }

    def _score_to_grade(
        self,
        score: float,
    ) -> str:
        """Puani nota cevirir."""
        if score >= 90:
            return "A"
        if score >= 80:
            return "B"
        if score >= 70:
            return "C"
        if score >= 60:
            return "D"
        return "F"

    def set_category_weight(
        self,
        category: str = "",
        weight: float = 1.0,
    ) -> dict[str, Any]:
        """Kategori agirligini ayarlar.

        Args:
            category: Kategori adi.
            weight: Agirlik (0.1-5.0).

        Returns:
            Ayarlama bilgisi.
        """
        try:
            if (
                category
                not in self.CATEGORIES
            ):
                return {
                    "set": False,
                    "error": (
                        f"Gecersiz: "
                        f"{category}"
                    ),
                }

            weight = max(
                0.1, min(5.0, weight)
            )
            self._categories[category][
                "weight"
            ] = weight

            return {
                "category": category,
                "weight": weight,
                "set": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "set": False,
                "error": str(e),
            }

    def set_benchmark(
        self,
        name: str = "",
        category: str = "",
        target_score: float = 80.0,
        industry: str = "",
    ) -> dict[str, Any]:
        """Kiyaslama hedefi belirler.

        Args:
            name: Kiyaslama adi.
            category: Kategori.
            target_score: Hedef puan.
            industry: Sektor.

        Returns:
            Kiyaslama bilgisi.
        """
        try:
            bid = f"bm_{uuid4()!s:.8}"
            self._benchmarks[bid] = {
                "benchmark_id": bid,
                "name": name,
                "category": category,
                "target_score": (
                    target_score
                ),
                "industry": industry,
                "set_at": datetime.now(
                    timezone.utc
                ).isoformat(),
            }
            self._stats[
                "benchmarks_set"
            ] += 1

            return {
                "benchmark_id": bid,
                "target_score": (
                    target_score
                ),
                "set": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "set": False,
                "error": str(e),
            }

    def get_scorecard(
        self,
    ) -> dict[str, Any]:
        """Tam puan karti getirir.

        Returns:
            Puan karti bilgisi.
        """
        try:
            overall = self.overall_score
            grade = self._score_to_grade(
                overall
            )

            categories = {}
            for name, cat in (
                self._categories.items()
            ):
                categories[name] = {
                    "score": cat["score"],
                    "grade": (
                        self._score_to_grade(
                            cat["score"]
                        )
                    ),
                    "weight": cat["weight"],
                }

            return {
                "overall_score": overall,
                "overall_grade": grade,
                "categories": categories,
                "total_assessments": len(
                    self._scores
                ),
                "retrieved": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "retrieved": False,
                "error": str(e),
            }

    def get_trend(
        self,
        category: str = "",
        limit: int = 10,
    ) -> dict[str, Any]:
        """Trend verisini getirir.

        Args:
            category: Kategori.
            limit: Limit.

        Returns:
            Trend bilgisi.
        """
        try:
            if category:
                history = [
                    {
                        "score": s["score"],
                        "assessed_at": s[
                            "assessed_at"
                        ],
                    }
                    for s in self._scores
                    if s["category"]
                    == category
                ]
            else:
                history = [
                    {
                        "score": s["score"],
                        "category": s[
                            "category"
                        ],
                        "assessed_at": s[
                            "assessed_at"
                        ],
                    }
                    for s in self._scores
                ]

            recent = history[-limit:]

            trend = "stable"
            if len(recent) >= 2:
                first_half = recent[
                    : len(recent) // 2
                ]
                second_half = recent[
                    len(recent) // 2 :
                ]
                avg1 = (
                    sum(
                        s["score"]
                        for s in first_half
                    )
                    / len(first_half)
                    if first_half
                    else 0
                )
                avg2 = (
                    sum(
                        s["score"]
                        for s in second_half
                    )
                    / len(second_half)
                    if second_half
                    else 0
                )
                if avg2 > avg1 + 2:
                    trend = "improving"
                elif avg2 < avg1 - 2:
                    trend = "declining"

            return {
                "category": (
                    category or "all"
                ),
                "data_points": len(recent),
                "trend": trend,
                "history": recent,
                "retrieved": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "retrieved": False,
                "error": str(e),
            }

    def track_improvement(
        self,
        category: str = "",
        action: str = "",
        expected_impact: float = 0.0,
        status: str = "planned",
    ) -> dict[str, Any]:
        """Iyilestirme takip eder.

        Args:
            category: Kategori.
            action: Aksiyon.
            expected_impact: Beklenen etki.
            status: Durum.

        Returns:
            Takip bilgisi.
        """
        try:
            iid = f"im_{uuid4()!s:.8}"
            self._improvements.append({
                "improvement_id": iid,
                "category": category,
                "action": action,
                "expected_impact": (
                    expected_impact
                ),
                "status": status,
                "created_at": datetime.now(
                    timezone.utc
                ).isoformat(),
            })
            self._stats[
                "improvements_tracked"
            ] += 1

            return {
                "improvement_id": iid,
                "tracked": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "tracked": False,
                "error": str(e),
            }

    def get_summary(
        self,
    ) -> dict[str, Any]:
        """Ozet getirir."""
        try:
            return {
                "overall_score": (
                    self.overall_score
                ),
                "overall_grade": (
                    self._score_to_grade(
                        self.overall_score
                    )
                ),
                "total_assessments": len(
                    self._scores
                ),
                "total_benchmarks": len(
                    self._benchmarks
                ),
                "total_improvements": len(
                    self._improvements
                ),
                "stats": dict(self._stats),
                "retrieved": True,
            }

        except Exception as e:
            logger.error(f"Hata: {e}")
            return {
                "retrieved": False,
                "error": str(e),
            }

"""
Penetration Test & Red Team Simulator
testleri.
"""

import pytest

from app.core.pentest.auto_pen_tester import (
    AutoPenTester,
)
from app.core.pentest.exploit_simulator import (
    ExploitSimulator,
)
from app.core.pentest.social_engineering_tester import (
    SocialEngineeringTester,
)
from app.core.pentest.weakness_ranker import (
    WeaknessRanker,
)
from app.core.pentest.remediation_planner import (
    RemediationPlanner,
)
from app.core.pentest.attack_surface_mapper import (
    AttackSurfaceMapper,
)
from app.core.pentest.red_team_scheduler import (
    RedTeamScheduler,
)
from app.core.pentest.security_scorecard import (
    SecurityScorecard,
)
from app.core.pentest.pentest_orchestrator import (
    PentestOrchestrator,
)


# ========================
# AutoPenTester
# ========================
class TestAutoPenTester:
    """AutoPenTester testleri."""

    def setup_method(self):
        self.pt = AutoPenTester(
            safe_mode=True
        )

    def test_init(self):
        assert self.pt._safe_mode is True
        assert len(self.pt._scenarios) >= 3

    def test_finding_count(self):
        assert self.pt.finding_count == 0

    def test_default_scenarios(self):
        assert "quick_scan" in self.pt._scenarios
        assert "web_full" in self.pt._scenarios
        assert "comprehensive" in self.pt._scenarios

    def test_create_scenario(self):
        r = self.pt.create_scenario(
            name="custom",
            tests=["port_scan", "ssl_check"],
            description="test",
        )
        assert r["created"] is True
        assert "custom" in self.pt._scenarios

    def test_run_test_valid(self):
        r = self.pt.run_test(
            test_type="port_scan",
            target="192.168.1.1",
        )
        assert r["completed"] is True
        assert r["findings"] >= 0

    def test_run_test_invalid(self):
        r = self.pt.run_test(
            test_type="invalid_test",
        )
        assert r["completed"] is False

    def test_run_test_injection(self):
        r = self.pt.run_test(
            test_type="injection_test",
            target="app.example.com",
        )
        assert r["completed"] is True
        assert r["findings"] > 0

    def test_run_scenario(self):
        r = self.pt.run_scenario(
            scenario_name="quick_scan",
            target="10.0.0.1",
        )
        assert r["completed"] is True
        assert r["tests_run"] == 2

    def test_run_scenario_invalid(self):
        r = self.pt.run_scenario(
            scenario_name="nonexistent",
        )
        assert r["completed"] is False

    def test_schedule_test(self):
        r = self.pt.schedule_test(
            scenario_name="quick_scan",
            target="10.0.0.1",
            frequency="daily",
        )
        assert r["scheduled"] is True

    def test_generate_report(self):
        run = self.pt.run_test(
            test_type="ssl_check",
            target="example.com",
        )
        tid = list(self.pt._tests.keys())[0]
        r = self.pt.generate_report(
            test_id=tid,
        )
        assert r["generated"] is True
        assert "by_severity" in r

    def test_generate_report_invalid(self):
        r = self.pt.generate_report(
            test_id="nonexistent",
        )
        assert r["generated"] is False

    def test_get_summary(self):
        r = self.pt.get_summary()
        assert r["retrieved"] is True
        assert "stats" in r

    def test_finding_count_after_test(self):
        self.pt.run_test(
            test_type="port_scan",
            target="test",
        )
        assert self.pt.finding_count >= 0


# ========================
# ExploitSimulator
# ========================
class TestExploitSimulator:
    """ExploitSimulator testleri."""

    def setup_method(self):
        self.es = ExploitSimulator(
            safe_mode=True
        )

    def test_init(self):
        assert self.es._safe_mode is True
        assert len(self.es._exploits) >= 4

    def test_simulation_count(self):
        assert self.es.simulation_count == 0

    def test_known_exploits(self):
        assert "sqli_basic" in self.es._exploits
        assert "xss_reflected" in self.es._exploits

    def test_register_exploit(self):
        r = self.es.register_exploit(
            name="custom_rce",
            category="rce",
            severity="critical",
        )
        assert r["registered"] is True

    def test_simulate_success(self):
        r = self.es.simulate(
            exploit_name="sqli_basic",
            target="db.example.com",
            simulated_success=True,
        )
        assert r["simulated"] is True
        assert r["success"] is True

    def test_simulate_blocked(self):
        r = self.es.simulate(
            exploit_name="sqli_basic",
            target="db.example.com",
            simulated_success=False,
        )
        assert r["simulated"] is True
        assert r["success"] is False

    def test_simulate_invalid(self):
        r = self.es.simulate(
            exploit_name="nonexistent",
        )
        assert r["simulated"] is False

    def test_assess_impact(self):
        sim = self.es.simulate(
            exploit_name="sqli_basic",
            target="test",
        )
        sid = sim["simulation_id"]
        r = self.es.assess_impact(
            simulation_id=sid,
        )
        assert r["assessed"] is True
        assert r["impact_score"] > 0

    def test_assess_impact_invalid(self):
        r = self.es.assess_impact(
            simulation_id="nonexistent",
        )
        assert r["assessed"] is False

    def test_validate_mitigation(self):
        r = self.es.validate_mitigation(
            exploit_name="sqli_basic",
            mitigation_id="waf_001",
            is_effective=True,
        )
        assert r["validated"] is True

    def test_impact_data_risk(self):
        sim = self.es.simulate(
            exploit_name="sqli_basic",
            target="test",
        )
        sid = sim["simulation_id"]
        r = self.es.assess_impact(
            simulation_id=sid,
        )
        assert r["data_risk"] is True

    def test_get_summary(self):
        r = self.es.get_summary()
        assert r["retrieved"] is True
        assert r["safe_mode"] is True


# ========================
# SocialEngineeringTester
# ========================
class TestSocialEngineeringTester:
    """SocialEngineeringTester testleri."""

    def setup_method(self):
        self.se = SocialEngineeringTester()

    def test_init(self):
        assert self.se.campaign_count == 0

    def test_create_campaign(self):
        r = self.se.create_campaign(
            name="phish_test",
            attack_type="phishing_email",
        )
        assert r["created"] is True

    def test_create_campaign_invalid(self):
        r = self.se.create_campaign(
            attack_type="invalid_type",
        )
        assert r["created"] is False

    def test_add_target(self):
        c = self.se.create_campaign(
            name="test",
        )
        cid = c["campaign_id"]
        r = self.se.add_target(
            campaign_id=cid,
            user_id="u1",
            email="test@example.com",
        )
        assert r["added"] is True

    def test_add_target_invalid_campaign(self):
        r = self.se.add_target(
            campaign_id="nonexistent",
        )
        assert r["added"] is False

    def test_send_test(self):
        c = self.se.create_campaign(
            name="test",
        )
        cid = c["campaign_id"]
        self.se.add_target(
            campaign_id=cid,
            user_id="u1",
        )
        r = self.se.send_test(
            campaign_id=cid,
        )
        assert r["sent"] is True
        assert r["targets_sent"] == 1

    def test_send_test_no_targets(self):
        c = self.se.create_campaign(
            name="empty",
        )
        r = self.se.send_test(
            campaign_id=c["campaign_id"],
        )
        assert r["sent"] is False

    def test_record_action_clicked(self):
        r = self.se.record_action(
            campaign_id="c1",
            target_id="t1",
            action="clicked",
        )
        assert r["recorded"] is True

    def test_record_action_reported(self):
        r = self.se.record_action(
            campaign_id="c1",
            target_id="t1",
            action="reported",
        )
        assert r["recorded"] is True

    def test_record_action_submitted(self):
        r = self.se.record_action(
            campaign_id="c1",
            target_id="t1",
            action="submitted_data",
        )
        assert r["recorded"] is True
        assert len(self.se._trainings) == 1

    def test_record_action_invalid(self):
        r = self.se.record_action(
            action="invalid_action",
        )
        assert r["recorded"] is False

    def test_awareness_score(self):
        c = self.se.create_campaign(
            name="score_test",
        )
        cid = c["campaign_id"]
        self.se.add_target(
            campaign_id=cid,
            user_id="u1",
        )
        tid = list(self.se._targets.keys())[0]
        self.se.record_action(
            campaign_id=cid,
            target_id=tid,
            action="reported",
        )
        r = self.se.get_awareness_score(
            campaign_id=cid,
        )
        assert r["scored"] is True
        assert r["score"] > 0.5

    def test_awareness_score_no_targets(self):
        c = self.se.create_campaign(
            name="empty",
        )
        r = self.se.get_awareness_score(
            campaign_id=c["campaign_id"],
        )
        assert r["scored"] is True
        assert r["score"] == 0.0

    def test_awareness_score_invalid(self):
        r = self.se.get_awareness_score(
            campaign_id="nonexistent",
        )
        assert r["scored"] is False

    def test_get_summary(self):
        r = self.se.get_summary()
        assert r["retrieved"] is True


# ========================
# WeaknessRanker
# ========================
class TestWeaknessRanker:
    """WeaknessRanker testleri."""

    def setup_method(self):
        self.wr = WeaknessRanker()

    def test_init(self):
        assert self.wr.weakness_count == 0

    def test_add_weakness(self):
        r = self.wr.add_weakness(
            name="sqli_vuln",
            category="injection",
            severity="critical",
            exploitability="functional",
            business_impact="catastrophic",
        )
        assert r["added"] is True
        assert r["cvss_score"] > 0

    def test_add_weakness_invalid(self):
        r = self.wr.add_weakness(
            severity="invalid",
        )
        assert r["added"] is False

    def test_cvss_calculation(self):
        r = self.wr.add_weakness(
            name="test",
            severity="critical",
            exploitability="weaponized",
            business_impact="catastrophic",
        )
        assert r["cvss_score"] >= 9.0

    def test_cvss_low(self):
        r = self.wr.add_weakness(
            name="info_leak",
            severity="low",
            exploitability="none",
            business_impact="none",
        )
        assert r["cvss_score"] <= 2.0

    def test_rank_weaknesses(self):
        self.wr.add_weakness(
            name="low_vuln",
            severity="low",
        )
        self.wr.add_weakness(
            name="crit_vuln",
            severity="critical",
        )
        r = self.wr.rank_weaknesses()
        assert r["ranked"] is True
        assert r["total"] == 2
        items = r["top_items"]
        assert items[0]["severity"] == "critical"

    def test_rank_empty(self):
        r = self.wr.rank_weaknesses()
        assert r["ranked"] is True
        assert r["total"] == 0

    def test_get_by_severity(self):
        self.wr.add_weakness(
            name="crit1",
            severity="critical",
        )
        self.wr.add_weakness(
            name="low1",
            severity="low",
        )
        r = self.wr.get_by_severity(
            severity="critical",
        )
        assert r["retrieved"] is True
        assert r["count"] == 1

    def test_close_weakness(self):
        w = self.wr.add_weakness(
            name="to_close",
            severity="medium",
        )
        wid = w["weakness_id"]
        r = self.wr.close_weakness(
            weakness_id=wid,
            resolution="patched",
        )
        assert r["closed"] is True

    def test_close_weakness_invalid(self):
        r = self.wr.close_weakness(
            weakness_id="nonexistent",
        )
        assert r["closed"] is False

    def test_closed_not_in_ranking(self):
        w = self.wr.add_weakness(
            name="closed_vuln",
            severity="high",
        )
        self.wr.close_weakness(
            weakness_id=w["weakness_id"],
        )
        r = self.wr.rank_weaknesses()
        assert r["total"] == 0

    def test_get_summary(self):
        self.wr.add_weakness(
            name="test",
            severity="high",
        )
        r = self.wr.get_summary()
        assert r["retrieved"] is True
        assert r["total_weaknesses"] == 1


# ========================
# RemediationPlanner
# ========================
class TestRemediationPlanner:
    """RemediationPlanner testleri."""

    def setup_method(self):
        self.rp = RemediationPlanner()

    def test_init(self):
        assert self.rp.plan_count == 0

    def test_create_plan(self):
        r = self.rp.create_plan(
            weakness_id="w1",
            name="fix_sqli",
            priority="p0_immediate",
        )
        assert r["created"] is True

    def test_create_plan_invalid(self):
        r = self.rp.create_plan(
            priority="invalid",
        )
        assert r["created"] is False

    def test_add_task(self):
        p = self.rp.create_plan(
            name="plan1",
        )
        pid = p["plan_id"]
        r = self.rp.add_task(
            plan_id=pid,
            name="task1",
            estimated_hours=4.0,
        )
        assert r["added"] is True

    def test_add_task_invalid_plan(self):
        r = self.rp.add_task(
            plan_id="nonexistent",
        )
        assert r["added"] is False

    def test_update_task_status(self):
        p = self.rp.create_plan(
            name="plan1",
        )
        t = self.rp.add_task(
            plan_id=p["plan_id"],
            name="task1",
        )
        r = self.rp.update_task_status(
            task_id=t["task_id"],
            status="completed",
        )
        assert r["updated"] is True

    def test_update_task_invalid(self):
        r = self.rp.update_task_status(
            task_id="nonexistent",
        )
        assert r["updated"] is False

    def test_update_task_invalid_status(self):
        p = self.rp.create_plan(
            name="plan1",
        )
        t = self.rp.add_task(
            plan_id=p["plan_id"],
            name="task1",
        )
        r = self.rp.update_task_status(
            task_id=t["task_id"],
            status="invalid",
        )
        assert r["updated"] is False

    def test_dependency_check(self):
        p = self.rp.create_plan(
            name="dep_test",
        )
        pid = p["plan_id"]
        t1 = self.rp.add_task(
            plan_id=pid,
            name="first",
        )
        t2 = self.rp.add_task(
            plan_id=pid,
            name="second",
            depends_on=[t1["task_id"]],
        )
        # t1 tamamlanmadan t2 baslayamaz
        r = self.rp.update_task_status(
            task_id=t2["task_id"],
            status="in_progress",
        )
        assert r["updated"] is False

    def test_dependency_resolved(self):
        p = self.rp.create_plan(
            name="dep_ok",
        )
        pid = p["plan_id"]
        t1 = self.rp.add_task(
            plan_id=pid,
            name="first",
        )
        t2 = self.rp.add_task(
            plan_id=pid,
            name="second",
            depends_on=[t1["task_id"]],
        )
        self.rp.update_task_status(
            task_id=t1["task_id"],
            status="completed",
        )
        r = self.rp.update_task_status(
            task_id=t2["task_id"],
            status="in_progress",
        )
        assert r["updated"] is True

    def test_estimate_timeline(self):
        p = self.rp.create_plan(
            name="timeline",
        )
        pid = p["plan_id"]
        self.rp.add_task(
            plan_id=pid,
            name="t1",
            estimated_hours=8.0,
            assignee="dev1",
        )
        self.rp.add_task(
            plan_id=pid,
            name="t2",
            estimated_hours=4.0,
            assignee="dev2",
        )
        r = self.rp.estimate_timeline(
            plan_id=pid,
        )
        assert r["estimated"] is True
        assert r["total_hours"] == 12.0
        assert r["parallel_factor"] == 2

    def test_estimate_timeline_invalid(self):
        r = self.rp.estimate_timeline(
            plan_id="nonexistent",
        )
        assert r["estimated"] is False

    def test_verify_remediation(self):
        p = self.rp.create_plan(
            name="verify",
        )
        r = self.rp.verify_remediation(
            plan_id=p["plan_id"],
            verifier_id="sec_team",
            is_fixed=True,
        )
        assert r["verified"] is True

    def test_verify_not_fixed(self):
        p = self.rp.create_plan(
            name="reopen",
        )
        r = self.rp.verify_remediation(
            plan_id=p["plan_id"],
            is_fixed=False,
        )
        assert r["verified"] is True
        plan = self.rp._plans[p["plan_id"]]
        assert plan["status"] == "reopened"

    def test_verify_invalid(self):
        r = self.rp.verify_remediation(
            plan_id="nonexistent",
        )
        assert r["verified"] is False

    def test_get_summary(self):
        self.rp.create_plan(
            name="s1",
            priority="p0_immediate",
        )
        r = self.rp.get_summary()
        assert r["retrieved"] is True
        assert r["by_priority"]["p0_immediate"] == 1


# ========================
# AttackSurfaceMapper
# ========================
class TestAttackSurfaceMapper:
    """AttackSurfaceMapper testleri."""

    def setup_method(self):
        self.asm = AttackSurfaceMapper()

    def test_init(self):
        assert self.asm.asset_count == 0

    def test_discover_asset(self):
        r = self.asm.discover_asset(
            name="web_server",
            asset_type="web_app",
            host="web.example.com",
            port=443,
        )
        assert r["discovered"] is True

    def test_discover_asset_invalid(self):
        r = self.asm.discover_asset(
            asset_type="invalid_type",
        )
        assert r["discovered"] is False

    def test_add_entry_point(self):
        a = self.asm.discover_asset(
            name="api",
            asset_type="api",
        )
        aid = a["asset_id"]
        r = self.asm.add_entry_point(
            asset_id=aid,
            name="login",
            protocol="HTTPS",
            endpoint="/api/login",
        )
        assert r["added"] is True

    def test_add_entry_point_invalid(self):
        r = self.asm.add_entry_point(
            asset_id="nonexistent",
        )
        assert r["added"] is False

    def test_analyze_exposure_external(self):
        a = self.asm.discover_asset(
            name="ext_app",
            asset_type="web_app",
            is_external=True,
            port=22,
        )
        aid = a["asset_id"]
        # 4 noktadan fazla
        for i in range(5):
            self.asm.add_entry_point(
                asset_id=aid,
                name=f"ep_{i}",
                auth_required=False,
            )
        r = self.asm.analyze_exposure(
            asset_id=aid,
        )
        assert r["analyzed"] is True
        assert r["exposure_score"] > 0.5

    def test_analyze_exposure_internal(self):
        a = self.asm.discover_asset(
            name="int_app",
            asset_type="database",
            is_external=False,
            port=80,
        )
        r = self.asm.analyze_exposure(
            asset_id=a["asset_id"],
        )
        assert r["analyzed"] is True
        assert r["exposure_score"] == 0.0

    def test_analyze_exposure_invalid(self):
        r = self.asm.analyze_exposure(
            asset_id="nonexistent",
        )
        assert r["analyzed"] is False

    def test_generate_map(self):
        self.asm.discover_asset(
            name="a1",
            asset_type="web_app",
        )
        self.asm.discover_asset(
            name="a2",
            asset_type="api",
            is_external=False,
        )
        r = self.asm.generate_map()
        assert r["generated"] is True
        assert r["total_assets"] == 2
        assert r["external_assets"] == 1

    def test_generate_map_empty(self):
        r = self.asm.generate_map()
        assert r["generated"] is True
        assert r["total_assets"] == 0

    def test_get_summary(self):
        r = self.asm.get_summary()
        assert r["retrieved"] is True
        assert "stats" in r

    def test_db_port_exposure(self):
        a = self.asm.discover_asset(
            name="db",
            asset_type="database",
            is_external=True,
            port=3306,
        )
        r = self.asm.analyze_exposure(
            asset_id=a["asset_id"],
        )
        assert r["exposure_score"] >= 0.5


# ========================
# RedTeamScheduler
# ========================
class TestRedTeamScheduler:
    """RedTeamScheduler testleri."""

    def setup_method(self):
        self.rts = RedTeamScheduler()

    def test_init(self):
        assert self.rts.exercise_count == 0

    def test_create_exercise(self):
        r = self.rts.create_exercise(
            name="annual_test",
            exercise_type="full_simulation",
            objectives=["breach", "exfil"],
        )
        assert r["created"] is True

    def test_create_exercise_invalid(self):
        r = self.rts.create_exercise(
            exercise_type="invalid",
        )
        assert r["created"] is False

    def test_register_team(self):
        r = self.rts.register_team(
            name="red_alpha",
            role="red",
            members=["m1", "m2"],
            lead="m1",
        )
        assert r["registered"] is True

    def test_assign_team(self):
        ex = self.rts.create_exercise(
            name="test",
        )
        tm = self.rts.register_team(
            name="team1",
        )
        r = self.rts.assign_team(
            exercise_id=ex["exercise_id"],
            team_id=tm["team_id"],
        )
        assert r["assigned"] is True

    def test_assign_team_invalid_ex(self):
        tm = self.rts.register_team(
            name="t1",
        )
        r = self.rts.assign_team(
            exercise_id="nonexistent",
            team_id=tm["team_id"],
        )
        assert r["assigned"] is False

    def test_assign_team_invalid_team(self):
        ex = self.rts.create_exercise(
            name="test",
        )
        r = self.rts.assign_team(
            exercise_id=ex["exercise_id"],
            team_id="nonexistent",
        )
        assert r["assigned"] is False

    def test_set_rules(self):
        ex = self.rts.create_exercise(
            name="rules_test",
        )
        r = self.rts.set_rules_of_engagement(
            exercise_id=ex["exercise_id"],
            allowed_techniques=["phishing"],
            forbidden_actions=["dos"],
            escalation_contact="ciso",
        )
        assert r["set"] is True

    def test_set_rules_invalid(self):
        r = self.rts.set_rules_of_engagement(
            exercise_id="nonexistent",
        )
        assert r["set"] is False

    def test_update_status(self):
        ex = self.rts.create_exercise(
            name="status_test",
        )
        r = self.rts.update_exercise_status(
            exercise_id=ex["exercise_id"],
            status="active",
        )
        assert r["updated"] is True

    def test_update_status_completed(self):
        ex = self.rts.create_exercise(
            name="complete_test",
        )
        r = self.rts.update_exercise_status(
            exercise_id=ex["exercise_id"],
            status="completed",
        )
        assert r["updated"] is True

    def test_update_status_invalid(self):
        ex = self.rts.create_exercise(
            name="test",
        )
        r = self.rts.update_exercise_status(
            exercise_id=ex["exercise_id"],
            status="invalid",
        )
        assert r["updated"] is False

    def test_create_debrief(self):
        ex = self.rts.create_exercise(
            name="debrief_test",
            objectives=["o1", "o2", "o3"],
        )
        r = self.rts.create_debrief(
            exercise_id=ex["exercise_id"],
            findings_count=5,
            objectives_met=2,
            lessons_learned=["lesson1"],
        )
        assert r["created"] is True
        assert abs(r["success_rate"] - 0.67) < 0.01

    def test_create_debrief_invalid(self):
        r = self.rts.create_debrief(
            exercise_id="nonexistent",
        )
        assert r["created"] is False

    def test_get_summary(self):
        r = self.rts.get_summary()
        assert r["retrieved"] is True
        assert "stats" in r


# ========================
# SecurityScorecard
# ========================
class TestSecurityScorecard:
    """SecurityScorecard testleri."""

    def setup_method(self):
        self.sc = SecurityScorecard()

    def test_init(self):
        assert self.sc.overall_score == 0.0
        assert len(self.sc._categories) == 8

    def test_assess_category(self):
        r = self.sc.assess_category(
            category="network_security",
            score=85.0,
        )
        assert r["assessed"] is True
        assert r["grade"] == "B"

    def test_assess_category_invalid(self):
        r = self.sc.assess_category(
            category="invalid_category",
        )
        assert r["assessed"] is False

    def test_grade_a(self):
        r = self.sc.assess_category(
            category="data_protection",
            score=95.0,
        )
        assert r["grade"] == "A"

    def test_grade_f(self):
        r = self.sc.assess_category(
            category="compliance",
            score=40.0,
        )
        assert r["grade"] == "F"

    def test_overall_score(self):
        self.sc.assess_category(
            category="network_security",
            score=80.0,
        )
        self.sc.assess_category(
            category="data_protection",
            score=60.0,
        )
        score = self.sc.overall_score
        assert score == 70.0

    def test_set_category_weight(self):
        r = self.sc.set_category_weight(
            category="network_security",
            weight=2.0,
        )
        assert r["set"] is True

    def test_set_weight_invalid(self):
        r = self.sc.set_category_weight(
            category="invalid",
        )
        assert r["set"] is False

    def test_weighted_score(self):
        self.sc.set_category_weight(
            category="network_security",
            weight=2.0,
        )
        self.sc.assess_category(
            category="network_security",
            score=90.0,
        )
        self.sc.assess_category(
            category="data_protection",
            score=60.0,
        )
        score = self.sc.overall_score
        # (90*2 + 60*1) / (2+1) = 80
        assert score == 80.0

    def test_set_benchmark(self):
        r = self.sc.set_benchmark(
            name="industry_avg",
            category="network_security",
            target_score=85.0,
        )
        assert r["set"] is True

    def test_get_scorecard(self):
        self.sc.assess_category(
            category="network_security",
            score=75.0,
        )
        r = self.sc.get_scorecard()
        assert r["retrieved"] is True
        assert r["overall_score"] == 75.0
        assert r["overall_grade"] == "C"

    def test_get_trend_empty(self):
        r = self.sc.get_trend()
        assert r["retrieved"] is True
        assert r["data_points"] == 0

    def test_get_trend_improving(self):
        for score in [50, 55, 60, 65, 70, 75, 80, 85]:
            self.sc.assess_category(
                category="network_security",
                score=float(score),
            )
        r = self.sc.get_trend(
            category="network_security",
        )
        assert r["retrieved"] is True
        assert r["trend"] == "improving"

    def test_get_trend_declining(self):
        for score in [90, 85, 80, 75, 70, 65, 60, 55]:
            self.sc.assess_category(
                category="data_protection",
                score=float(score),
            )
        r = self.sc.get_trend(
            category="data_protection",
        )
        assert r["trend"] == "declining"

    def test_track_improvement(self):
        r = self.sc.track_improvement(
            category="compliance",
            action="implement_soc2",
            expected_impact=15.0,
        )
        assert r["tracked"] is True

    def test_get_summary(self):
        r = self.sc.get_summary()
        assert r["retrieved"] is True
        assert "overall_score" in r


# ========================
# PentestOrchestrator
# ========================
class TestPentestOrchestrator:
    """PentestOrchestrator testleri."""

    def setup_method(self):
        self.po = PentestOrchestrator(
            safe_mode=True,
        )

    def test_init(self):
        assert self.po._safe_mode is True
        assert self.po.pen_tester is not None
        assert self.po.exploit_sim is not None

    def test_run_full_scan(self):
        r = self.po.run_full_scan(
            target="test.example.com",
            scenario="quick_scan",
        )
        assert r["completed"] is True
        assert r["target"] == "test.example.com"

    def test_run_full_scan_comprehensive(self):
        r = self.po.run_full_scan(
            target="app.example.com",
            scenario="comprehensive",
        )
        assert r["completed"] is True
        assert r["total_findings"] > 0

    def test_simulate_exploit(self):
        r = self.po.simulate_exploit(
            exploit_name="sqli_basic",
            target="db.example.com",
        )
        assert r["simulated"] is True
        assert r["impact"] > 0

    def test_simulate_exploit_invalid(self):
        r = self.po.simulate_exploit(
            exploit_name="nonexistent",
        )
        assert r["simulated"] is False

    def test_plan_remediation(self):
        r = self.po.plan_remediation(
            weakness_name="sqli_vuln",
            priority="p1_urgent",
            team="security",
        )
        assert r["planned"] is True

    def test_plan_remediation_invalid(self):
        r = self.po.plan_remediation(
            weakness_name="test",
            priority="invalid",
        )
        assert r["planned"] is False

    def test_run_social_engineering(self):
        r = self.po.run_social_engineering(
            campaign_name="phish_test",
            targets=[
                {"user_id": "u1", "email": "u1@test.com"},
                {"user_id": "u2", "email": "u2@test.com"},
            ],
        )
        assert r["completed"] is True
        assert r["targets_added"] == 2

    def test_run_social_engineering_invalid(self):
        r = self.po.run_social_engineering(
            attack_type="invalid",
        )
        assert r["completed"] is False

    def test_update_scorecard(self):
        r = self.po.update_scorecard(
            category="network_security",
            score=85.0,
        )
        assert r["updated"] is True
        assert r["grade"] == "B"

    def test_update_scorecard_invalid(self):
        r = self.po.update_scorecard(
            category="invalid",
        )
        assert r["updated"] is False

    def test_get_analytics(self):
        self.po.run_full_scan(
            target="test.com",
            scenario="quick_scan",
        )
        r = self.po.get_analytics()
        assert r["retrieved"] is True
        assert "pen_tests" in r
        assert "scorecard" in r

    def test_get_summary(self):
        r = self.po.get_summary()
        assert r["retrieved"] is True
        assert r["safe_mode"] is True


# ========================
# Models
# ========================
class TestPentestModels:
    """Pentest model testleri."""

    def test_test_type_enum(self):
        from app.models.pentest_models import TestType
        assert TestType.PORT_SCAN == "port_scan"
        assert len(TestType) == 8

    def test_severity_level_enum(self):
        from app.models.pentest_models import SeverityLevel
        assert SeverityLevel.CRITICAL == "critical"

    def test_exploit_category_enum(self):
        from app.models.pentest_models import ExploitCategory
        assert ExploitCategory.SQL_INJECTION == "sql_injection"
        assert len(ExploitCategory) == 9

    def test_attack_type_enum(self):
        from app.models.pentest_models import AttackType
        assert AttackType.PHISHING_EMAIL == "phishing_email"
        assert len(AttackType) == 7

    def test_exercise_type_enum(self):
        from app.models.pentest_models import ExerciseType
        assert ExerciseType.FULL_SIMULATION == "full_simulation"

    def test_exercise_status_enum(self):
        from app.models.pentest_models import ExerciseStatus
        assert ExerciseStatus.PLANNED == "planned"

    def test_remediation_priority_enum(self):
        from app.models.pentest_models import RemediationPriority
        assert RemediationPriority.P0_IMMEDIATE == "p0_immediate"

    def test_security_grade_enum(self):
        from app.models.pentest_models import SecurityGrade
        assert SecurityGrade.A == "A"

    def test_pen_test_finding(self):
        from app.models.pentest_models import PenTestFinding
        f = PenTestFinding(
            finding_id="f1",
            severity="critical",
        )
        assert f.severity == "critical"

    def test_exploit_simulation(self):
        from app.models.pentest_models import ExploitSimulation
        s = ExploitSimulation(
            success=True,
            impact_score=0.8,
        )
        assert s.success is True

    def test_weakness_record(self):
        from app.models.pentest_models import WeaknessRecord
        w = WeaknessRecord(
            cvss_score=9.5,
            status="open",
        )
        assert w.cvss_score == 9.5

    def test_remediation_plan(self):
        from app.models.pentest_models import RemediationPlan
        p = RemediationPlan(
            priority="p0_immediate",
            tasks=["t1", "t2"],
        )
        assert len(p.tasks) == 2

    def test_attack_surface(self):
        from app.models.pentest_models import AttackSurface
        a = AttackSurface(
            is_external=True,
            exposure_score=0.7,
        )
        assert a.exposure_score == 0.7

    def test_red_team_exercise(self):
        from app.models.pentest_models import RedTeamExercise
        e = RedTeamExercise(
            objectives=["breach"],
        )
        assert len(e.objectives) == 1

    def test_security_score(self):
        from app.models.pentest_models import SecurityScore
        s = SecurityScore(
            overall_score=85.0,
            overall_grade="B",
        )
        assert s.overall_grade == "B"

    def test_pentest_status(self):
        from app.models.pentest_models import PentestStatus
        s = PentestStatus(
            safe_mode=True,
            total_tests=10,
        )
        assert s.total_tests == 10


# ========================
# Config
# ========================
class TestPentestConfig:
    """Config testleri."""

    def test_pentest_settings(self):
        from app.config import settings
        assert hasattr(settings, "pentest_enabled")
        assert hasattr(settings, "auto_scan_frequency")
        assert hasattr(settings, "pentest_safe_mode")
        assert hasattr(settings, "social_engineering")
        assert hasattr(settings, "scorecard_enabled")

    def test_pentest_defaults(self):
        from app.config import settings
        assert settings.pentest_enabled is True
        assert settings.auto_scan_frequency == "weekly"
        assert settings.pentest_safe_mode is True
